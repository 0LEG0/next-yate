/**
 * @file "Next-Yate"
 * @author Anton <aucyxob@gmail.com>
 * @version 0.0.5
 * @license Apache-2.0
 * @description Next-Yate is Nodejs External module for YATE (Yet Another Telephony Engine).
 * @see https://github.com/0LEG0/next-yate
 */
"use strict";

// imports
const { Console } = require("console");
const { Writable } = require("stream");
const { Socket } = require("net");
const { EventEmitter } = require("events");
const { createInterface } = require("readline");

// defaults
const _TRACKNAME = "next-yate";
const _BUFFER_SIZE = 8192; // default 8192
const _DISPATCH_TIMEOUT = 10000; // default 10000
const _ACKNOWLEDGE_TIMEOUT = 10000; // default 10000
const _RECONNECT_TIMEOUT = 10000;
const _PORT = 5040;
//const _HOST = "127.0.0.1";
const _OFFLINE_QUEUE = 100; // default 10

/**
 * YateMessage is object Yate can interact with.
 * YateMessage can be of two types:<ul>
 * <li>"incoming" - message generated by Engine to Application and can be handled using a callback in the Yate.install or Yate.watch methods</li>
 * <li>"outgoing" - new Message generated by Application and sent to Engine using the Yate.dispatch or Yate.enqueue methods</li>
 * </ul>
 * @class
 * @param {string} name - message name (required)
 * @param {boolean} broadcast (not used)
 * @param {Object} params - message parameters (optional)
 * @example
 * const {Yate, YateMessage} = require("next-yate");
 * let yate = new Yate();
 * yate.init();
 * let m = new YateMessage("call.drop", { id: "sip/123", reason: "timeout" });
 * yate.enqueue(m);
 * @see Yate
 */
class YateMessage {
	constructor(name, broadcast, params) {
		if (typeof name !== "string" || name.length < 1) throw new Error("Message name are required!");
		if (typeof broadcast === "boolean") this._broadcast = broadcast;
		if (typeof broadcast === "object" && broadcast) params = broadcast;
		this._name = name;
		this._time = Math.floor(Date.now() / 1000); //sec
		this._id = `${this._time}.${process.hrtime()[1]}`;
		this._type = "outgoing";
		this._handled = false;
		this.copyParams(params, "", false);
	}

	get name() { return this._name }
	set name(value) { this._name = typeof value === "string" ? value : this._name }
	get time() { return this._time }
	set time(value) { this._time = typeof value === "string" ? value : this._time }
	get handled() { return this._handled }
	set handled(value) { this._handled = typeof value === "boolean" ? value : this._handled }

	/**
	 * @method
	 * @param {string} name - name of the parameter to retrieve (requred)
	 * @param {any} defValue - value to return if parameter is missing (optional)
	 * @param {boolean} autoNumber - automatically convert parameters to boolean or number type, default true (optional)
	 * @returns {any} - value of parameter
	 */
	getParam(name, defValue, autoNumber) {
		if (name === "name") return this._name; // workaround
		if (name === "broadcast") return this._broadcast; // workaround
		if (this[name] === "undefined") return defValue;
		return autoNumber ? this[name] : this[name] + "";
	}
	/**
	 * @method
	 * @param {string} name - name of the parameter to set (required)
	 * @param {any} value - new value to set in parameter, undefined to delete the parameter
	 * @returns {boolean} - true on success, false if message was not in a state where parameters can be changed
	 */
	setParam(name, value) {
		if (("" + name).charAt(0) === "_") return false;
		this[name] = value;
		return true;
	}
	/**
	 * @method
	 * @param {Object} obj - object from which to copy properties (required)
	 * @param {string} prefix - parameters begins with prefix (optional)
	 * @param {string} skip - will be ignored (optional)
	 */
	copyParams(obj, prefix, skip) {
		/*
		 * obj - object from which to copy properties (except objects, null and undefined)
		 * prefix - optional parameter to specify that only properties that a key with the given index should be copied. If the prefix represents an object, the properties of that object will be copied.
		 * skip - optional parameter (assumed, by default, to be true) to specifies if the prefix should be copied or eliminated from the key being copied.
		 */
		if (!obj) return;
		if (typeof obj !== "object") return;
		_deepCopy(this, obj, prefix, skip);
	}
	/**
	 * @method
	 * @param {string} value - new returned value to set in the message, if undefined method returns "Returned value of the message" (optional)
	 * @returns {string} - returned value of the message
	 */
	retValue(value) {
		if (value === undefined) return this._retvalue;
		this._retvalue = value;
	}
	/**
	 * @method
	 * @returns {number} - Message creation time in milliseconds since EPOCH
	 */
	msgTime() {	return this._time }
	getColumn() {} // TODO
	getRow() {} // TODO
	getResult() {} // TODO
}
Object.defineProperties(YateMessage.prototype, {
	getParam: { writable: false },
	setParam: { writable: false },
	copyParams: { writable: false },
	retValue: { writable: false },
	msgTime: { writable: false },
	getColumn: { writable: false },
	getRow: { writable: false },
	getResult: { writable: false }
});

/**
 * Yate object provides connection to Yate's external module.
 * @class
 * @param {Object} options - (optional)
 * @param {string} options.host - address of listerning Yate's extmodule for ex. "127.0.0.1", default "undefined", stdin/stdout connected
 * @param {number} options.port - port default 5040
 * @param {string} options.path - socket path, default "undefined"
 * @param {string} options.trackname - track name of connected script, default "next-yate"
 * @param {boolean} options.reconnect - reconnect on collisions, default true
 * @param {number} options.reconnnect_timeout - reconnect tries interval in milliseconds, default 10000
 * @param {number} options.dispatch_timeout - auto drop the response waiting in Yate.dispatch method after the timeout in milliseconds if Engine not respond, default 10000
 * @param {number} options.acknowledge_timeout - auto reply to incoming message as is if the callback function did not responded in the timeout, so as not to overload the Engine queue and not cause the engine to crash. default 10000
 * @param {number} options.bufsize - sets the maximum size of transferred data in extmodule, oversize will be truncated to the specified value, default 8192.
 * @param {boolean} options.channel - to run the Application in channel mode ^NNN=extmodule/nodata/node.sh example.js
 * @example
 * const {Yate} = require("next-yate");
 * let yate = new Yate({host: "127.0.0.1", trackname: "myscript"});
 * yate.init();
 * yate.output("Hello World!");
 * @see Yate#init
 * @see Yate#toChannel
 * @see https://docs.yate.ro/wiki/External_module_command_flow
 */
class Yate extends EventEmitter {
	constructor(options) {
		super();

		if (typeof options !== "object") options = {};

		this._socket = null;
		this._connected = false;
		this._debug = "debug" in options ? options.debug : false;
		this._host = options.host; // "127.0.0.1"
		this._port = options.port ? options.port : _PORT;
		this._path = options.path; // "socket path"
		this._reconnect = "reconnect" in options ? options.reconnect : true;
		this._reconnnect_timeout = options.reconnnect_timeout ? options.reconnnect_timeout : _RECONNECT_TIMEOUT;
		this._dispatch_timeout = options.dispatch_timeout ? options.dispatch_timeout : _DISPATCH_TIMEOUT;
		this._acknowledge_timeout = options.acknowledge_timeout ? options.acknowledge_timeout : _ACKNOWLEDGE_TIMEOUT;
		this._bufsize = options.bufsize ? options.bufsize : _BUFFER_SIZE;
		this._trackname = options.trackname ? options.trackname : _TRACKNAME;
		this._channel = "channel" in options ? options.channel : false;
		this.setMaxListeners(options.queue ? options.queue : _OFFLINE_QUEUE);

		/*
		 * Reconnection memory of
		 * setlocals, installs, watches
		 */
		// {name, value}
		this._setlocals = [{ name: "trackparam", value: this._trackname }];
		if (this._bufsize !== _BUFFER_SIZE) this._setlocals.push({ name: "bufsize", value: this._bufsize });
		if (this._reconnect) this._setlocals.push({ name: "restart", value: this._reconnect });
		if (this._acknowledge_timeout !== _ACKNOWLEDGE_TIMEOUT) this._setlocals.push({ name: "timeout", value: this._acknowledge_timeout });

		// {callback, name, priority, filter, fvalue}
		this._installs = [];
		// {callback, name}
		this._watches = [];

		// Dumped stream
		this._dump = new DumpStream();
		this._dump.on("dump", dump => this.output(dump));
		// Console -> Dumped stream -> Yate.output
		this._console = new Console(this._dump);

		if (!this._host) {
			// local streams
			this.in = process.stdin;
			this.out = process.stdout;
			this._reconnect = false;
			console = this._console; // console -> Yate.output
		} else {
			// do not reconnect on exit
			process.on("SIGINT", () => {
				if (this._socket) this._socket.end();
				this._reconnect = false;
				this.removeAllListeners();
				setTimeout(process.exit, 100);
			});
		}
	}

	get trackname() { return this._trackname }
	set trackname(name) { if (typeof name === "string") this.setlocal(() => {this._trackname = name}, "trackparam", name) }
	get reconnect() { return this._reconnect }
	set reconnect(value) { if (typeof value === "boolean") this.setlocal(() => {this._reconnect = value}, "restart", value) }
	get debug() { return this._debug }
	set debug(value) { if (typeof value === "boolean") this._debug = value }
	get connected() { return this._connected }
	set connected(value) {} // readonly
	get bufsize() { return this._bufsize }
	set bufsize(value) { if (typeof value === "number" && /^\d{3,5}$/.test("" + value) ) this.setlocal(() => {this._bufsize = value}, "bufsize", value)}
	get dispatch_timeout() { return this._dispatch_timeout }
	set dispatch_timeout(value) { if (typeof value === "number" && /^\d{3,}$/.test("" + value) ) this._dispatch_timeout = value }
	get acknowledge_timeout() { return this._acknowledge_timeout }
	set acknowledge_timeout(value) { if (typeof value === "number" && /^\d{3,}$/.test("" + value) ) this.setlocal(() => {this._acknowledge_timeout = value}, "timeout", value)}
	get channel() { return this._channel }
	set channel(value) {} // readonly
	get socket() { return this._socket }
	set socket(value) {} // readonly
	get host() { return this._host }
	set host(value) {} // readonly
	get port() { return this._port }
	set port(value) {} // readonly
	get path() { return this._path }
	set path(value) {} // readonly

	/**
	 * Initialize the Yate instance.
	 * Connects it to Extmodule. Makes readable and writable inbound and outbound streams. 
	 * @method
	 * @param {function} callback
	 * @example
	 * let yate = new Yate();
	 * yate.init(() => { console.log("Connnected") });
	 * @see Yate#toChannel
	 */
	init(callback) {
		if (this._channel) return this.toChannel();
		if (!this._host) {
			// local start
			this._restore(callback); // <-- start here
			return;
		}
		if (this._connected) return;
		if (this.timer) clearTimeout(this.timer);

		this._socket = new Socket(); // network start

		this._socket.on("connect", () => {
			this.in = this.out = this._socket;
			this._restore(callback); // <-- or start here
		});

		this._socket.on("end", () => {
			this._connected = false;
			this.emit("_disconnect");
			if (this._reconnect)
				this.timer = setTimeout(() => {
					this.init();
				}, this._reconnnect_timeout);
		});

		this._socket.on("error", error => {
			this._connected = false;
			if (this._reconnect) {
				this.timer = setTimeout(() => {
					this.init(callback);
				}, this._reconnnect_timeout);
			} else {
				this.emit("_error", error);
			}
		});

		this._socket.connect({
			path: this._path,
			port: this._port,
			host: this._host,
			timeout: this.timeout
		});
	}

	// restore handlers
	_restore(callback) {
		if (this._connected) return;
		this._connected = true;
		let rl = createInterface(this.in);
		rl.on("line", line => {
			this._read(line);
		});
		// restore: setlocal, install & watch
		this._setlocals.forEach(item => {
			this._setlocal(item.name, item.value);
		});
		this._installs.forEach(item => {
			this.removeAllListeners(item.name);
			this.install(item.callback, item.name, item.priority, item.filter, item.fvalue);
		});
		this._watches.forEach(item => {
			this.removeAllListeners(item.name);
			this.watch(item.callback, item.name, item.priority, item.filter, item.fvalue);
		});
		this.emit("_connect");
		if (typeof callback === "function") callback(this);
	}

	/**
	 * Alternative initialization of Yate in channel mode with the special Channel object. 
	 * New instance of Yate --> Yate.toChannel --> Channel.init --> callback
	 * @method
	 * @async
	 * @returns {Object} Channel
	 * @example
	 * regexroute.conf:
	 * ^NNN=extmodule/nodata/node.sh example.js
	 * 
	 * example.js:
	 * const {Yate} = require("next-yate");
	 * const yate = new Yate();
	 * const Channel = yate.toChannel();
	 * Channel.init(main, {autoanswer: true});
	 * 
	 * function main(message) {
	 *     if (message.called=="32843")
	 *         Channel.callJust("wave/play/./share/sounds/welcome.au");
	 * }
	 * @see Yate#init
	 */
	toChannel() {
		if (typeof this._channel === "object") return this._channel;
		if (this._host || this._connected) return;
		this._reconnect = false;
		this._connected = true;
		const _yate = this;

		/**
		 * Channel object generated by Yate.toChannel method
		 * @namespace Channel
		 */
		const channel = {
			peerid: null,
			id: _yate._trackname + "/" + Date.now(),
			status: null
		};
		/** @method Channel.ringing */
		channel.ringing = (params) => {
			let ringing = new YateMessage("call.ringing", {
				id: channel.id,
				targetid: channel.peerid,
				earlymedia: true
			});
			channel.status = "ringing";
			if (typeof params === "object") ringing.copyParams(params);
			return _yate.dispatch(ringing);
		};
		/** @method Channel.answered */
		channel.answered = (params) => {
			let answered = new YateMessage("call.answered", {
				id: channel.id,
				targetid: channel.peerid
			});
			channel.status = "answered";
			if (typeof params === "object") answered.copyParams(params);
			return _yate.dispatch(answered);
		};
		/** @method Channel.hangup */
		channel.hangup = (reason) => {
			return _yate.dispatch(new YateMessage("call.drop", {reason: reason, id: channel.id}));
		};
		/** @method Channel.callTo */
		channel.callTo = (dst, params = {}) => {
			if (typeof dst !== "string") return;
			let attach = new YateMessage("chan.attach", { notify: channel.id });
			if (dst.startsWith("wave/record")) {
				// wave/record
				attach.source = "";
				attach.consumer = dst;
				attach.maxlen = 180000; //default 10 sec
			} else {
				// wave/play, tone/
				attach.source = dst;
				attach.consumer = "wave/record/-";
			}
			if (typeof params === "object") attach.copyParams(params);
			return new Promise(resolve => {
				_yate.once("chan.notify", (msg) => {
					if (msg.targetid === channel.id) resolve(channel);
				});
				_yate.enqueue(attach);
			})
		};
		/** @method Channel.callJust */
		channel.callJust = (dst, params = {}) => {
			if (typeof dst !== "string") return;
			let execute = new YateMessage("chan.masquerade", {
				message: "call.execute",
				id: channel.peerid,
				callto: dst
			});
			if (typeof params === "object") execute.copyParams(params);
			_yate.enqueue(execute);
			setTimeout(() => {process.exit(0)}, 3);
		};

		/** 
		 * @method Channel.init
		 * @async
		 * @param {function} callback - initialization callback
		 * @param {Object} params - params will be attached to first incoming call.execute message
		 * @returns {YateMessage} - first incoming call.execute message
		 * @description Channel must be activated before use with init([callback],[params]) method
		 */
		channel.init = (callback, params) => {
			if (channel.peerid) return;
			_yate.setlocal("id", channel.id);
			_yate.install(() => {}, "chan.notify", 100, "targetid", channel.id);
			return new Promise( resolve => {
				_yate.once("call.execute", (message) => {
					channel.peerid = message.id;
					channel.status = message.status;
					message._handled = true;
					message.targetid = channel.id;
					if (typeof callback === "object") message.copyParams(callback);
					if (typeof params === "object") message.copyParams(params);
					_yate.acknowledge(message);
					if (typeof callback === "function") callback(message);
					resolve(message);
				})
			})
		};

		this._channel = channel;

		let rl = createInterface(this.in);
		rl.on("line", line => {
			this._read(line);
		});

		this.emit("_connect");

		return channel;
	}

	/**
	 * Returns Console connected to Yate's output
	 * @method
	 * @returns {Console}
	 * @example
	 * yate.getConsole().log("Find this message in yate's output");
	 */
	getConsole() { return this._console }

	/**
	 * Returns set of connection's specific parameners
	 * @method
	 * @async
	 * @param {function} callback
	 * @returns {Object}
	 * {
	 *   version: '6.1.1',
	 *   release: 'devel1',
	 *   nodename: 'svn',
	 *   runid: '1580736088',
	 *   configname: 'yate',
	 *   sharedpath: './share',
	 *   configpath: './conf.d',
	 *   cfgsuffix: '.conf',
	 *   modulepath: './modules',
	 *   modsuffix: '.yate',
	 *   logfile: '',
	 *   clientmode: 'false',
	 *   supervised: 'false',
	 *   maxworkers: '10'
	 * }
	 */
	getEnvironment(callback) {
		let env = [ 
			"version", "release", "nodename", "runid", "configname",
			"sharedpath", "configpath", "cfgsuffix", "modulepath",
			"modsuffix", "logfile", "clientmode", "supervised", "maxworkers"
		];
		let ans = {};

		return Promise.all(
			env.map(key => {
				return new Promise(resolve => {
					this.setlocal(value => {
						ans[key] = value;
						resolve(value);
					}, "engine." + key);
				})
			})
		).then(() => {
			if (typeof callback === "function") callback(ans);
			return ans;
		});
	}

	/**
	 * Acknowledges the message
	 * Not needed in common cases because of all incoming messages acknowledges automatically
	 * @method
	 * @param {YateMessage} message 
	 */
	acknowledge(msg) {
		if (typeof msg === "object" && msg._type === "incoming") { this._acknowledge(msg) }
	}

	/**
	 * Sets the handler to a specific message.
	 * The yate engine will wait for a response to its message.
	 * @method
	 * @param {function} callback - function to be message handler (required)
	 * @param {string} name - message name (required)
	 * @param {number} priority - priority of the handler, as low value as high proirity (optional, default 100)
	 * @param {string} filter - set the filter to message parameter (optional, for example "called")
	 * @param {string} fvalue - filter value (optional, for example "^9999.*")
	 * @example
	 * const {Yate, YateMessage} = require("next-yate");
	 *
	 * function onRoute(message) {
	 *     message.retValue("tone/ring"); // send the incoming call to tone/ring module
	 * }
	 *
	 * let yate = new Yate();
	 * yate.init();
	 * yate.install(onRoute, "call.route", 90, "called", "^9999.*"); // set the handler to "call.route" messages where parameter message.called begins with "9999", handler has priority 90
	 * @see YateMessage
	 * @see https://docs.yate.ro/wiki/Standard_Messages
	 */
	install(callback, name, priority, filter, fvalue) {
		let _yate = this;
		if (typeof callback === "function" && typeof name === "string") {
			if (typeof priority !== "number") {
				fvalue = typeof filter === "string" ? filter : undefined;
				filter = typeof priority === "string" ? priority : undefined;
				priority = 100;
			}
			// 1. query yate to install the handler
			this._install(name, priority, filter, fvalue);
			// 2. waiting for answer
			this.once("_install," + name, success => {
				// 3. on successful answer set the callback handler
				if (!success) return;
				// replace existing handler or append new one
				let idx = this._installs.length;
				for (let i = 0; i < this._installs.length; i++) {
					if (this._installs[i].name === name) {
						idx = i;
						break;
					}
				}
				this._installs[idx] = {
					callback: callback,
					name: name,
					priority: priority,
					filter: filter,
					fvalue: fvalue
				};
				this.on(name, message => {
					// setup acknowledge by timeout
					let timeout = setTimeout(() => {
						_yate.emit("_debug", "<" +_yate._trackname + ":WARN> " + message._id + " Message '" + message._name + "' acknowledge timeout!");
						this._acknowledge(message);
					}, this._acknowledge_timeout);

					// 4. promisify the (callback + acknowledge) )
					let calltype = Object.getPrototypeOf(callback).constructor.name;
					let promise; // it can be promise
					if (calltype === "AsyncFunction" || calltype === "Promise")	promise = callback;
					else promise = (msg) =>	new Promise( (resolve) => { resolve(callback(msg)) });

					// 5. attach acknowledge
					return promise(message).then((ans) => {
							clearTimeout(timeout);
							if (message._acknowledged) {
								// WARN message already acknowledged
								_yate.emit("_debug", "<" + _yate._trackname + ":WARN> " + message._id + " Message '" + message._name + "' already acknowledged!");
								return;
							}
							if (typeof ans === "boolean") {
								// if answer is boolean -> message.processed -> ack
								message._handled = ans;
								this._acknowledge(message);
								return;
							}
							if (ans && typeof ans === "object") {
								// if answer is changed message -> ack
								if (ans._id === message._id) {
									this._acknowledge(ans);
									return;
								}
							}
                            this._acknowledge(message); // EVERY message must be acknowledged!
                            
						}).catch(() => this._acknowledge(message)); // ...on error too
				});
			});
		} else throw new Error("Install message handler error!\nMethod install(callback, name, priority, filter, fvalue)");
	}

	/**
	 * Removes the handler from a specific Engine message
	 * @method
	 * @param {string} name - message name (required)
	 * @example
	 * yate.uninstall("call.route");
	 * @see Yate#install
	 */
	uninstall(name) {
		if (typeof name === "string") {
			this.once("_uninstall," + name, success => {
				if (!success) return;
				this.removeAllListeners(name);
				for (let i = 0; i < this._installs.length; i++)
					if (this._installs[i].name === name) {
						delete this._installs[i];
						break;
					}
			});
			this._uninstall(name);
		} else throw new Error("Uninstall message handler error!\nMethod uinstall(name)");
	}

	/**
	 * Sets the handler to a specific yate message.
	 * In contrast to the method of Yate.install it does not require an answer to message. You will get already handled messages.
	 * @method
	 * @param {function} callback - function to be message handler (required)
	 * @param {string} name - message name (required)
	 * @example
	 * const {Yate, YateMessage} = require("next-yate");
	 *
	 * function onTimer(message) {
	 *     concole.log(message.time);
	 * }
	 *
	 * let yate = new Yate();
	 * yate.init();
	 * yate.watch(onTimer, "engine.timer");
	 * @see https://docs.yate.ro/wiki/Standard_Messages
	 * @see Yate#install
	 */
	watch(callback, name) {
		if (typeof callback === "function" && typeof name === "string") {
			this.once("_watch," + name, success => {
				if (!success) return;
				this.on(name, callback);
				//
				let idx = this._watches.length;
				for (let i = 0; i < this._watches.length; i++)
					if (this._watches[i].name === name) {
						idx = i;
						break;
					}
				this._watches[idx] = { callback: callback, name: name };
				//
			});
			this._watch(name);
		} else throw new Error("Watch message handler error!\nMethod watch(callback, name)");
	}

	/**
	 * Removes the watch handler from a specific yate message
	 * @method
	 * @param {string} name - message name (required)
	 * @example
	 * yate.unwatch("engine.timer");
	 * @see Yate#watch
	 */
	unwatch(name) {
		if (typeof name === "string") {
			this.once("_unwatch," + name, success => {
				if (!success) return;
				this.removeAllListeners(name);
				for (let i = 0; i < this._watches.length; i++)
					if (this._watches[i].name === name) {
						delete this._watches[i];
						break;
					}
			});
			this._unwatch(name);
		} else throw new Error("Unwatch message handler error!\nMethod unwatch(name)");
	}

	/**
	 * Set/change/read extmodule connection parameters.
	 * @method
	 * @param {function} callback - result handler (optional, if undefined returns promisyfied value)
	 * @param {string} name - parameter name (required)
	 * @param {string} value - parameter value (optional, if undefined the method returns the parameter value)
	 * @async
	 * @example
	 * const {Yate, YateMessage} = require("next-yate");
	 * let yate = new Yate();
	 * yate.init();
	 * // callback variant
	 * yate.setlocal(console.log, "engine.version"); // output value to console
	 * // or async/await variant
	 * let ver = await yate.setlocal("engine.version");
	 * console.log(ver);
	 * @see https://docs.yate.ro/wiki/External_module_command_flow
	 */
	setlocal(callback, name, value) {
		// callback version
		if (
            typeof callback === "function" && typeof name === "string" &&
            (typeof value === "string" || typeof value === "boolean" || typeof value === "number" || value === undefined)
        ) {
			this.once("_setlocal," + name, (ans) => {
				// push or replace to setlocals []
				if (value !== undefined && ans._success) {
					let idx = this._setlocals.length;
					for (let i = 0; i < this._setlocals.length; i++) {
						if (this._setlocals[i].name === name) {
							idx = i;
							break;
						}
					}
					this._setlocals[idx] = { name: name, value: value };
				}
				callback(ans._success ? ans._retvalue : undefined );
			});
			this._setlocal(name, value);
			return;
		}
		// or promise version without callback
		if ( typeof callback === "string" &&
			(typeof name === "string" || typeof name === "boolean" || typeof name === "number" || value === undefined)
		) {
			value = name;
			name = callback;
			return new Promise( (resolve) => {
				this._setlocal(name, value);
				let event = "_setlocal," + name;
				// kill the slow setlocal query by timeout
				let timeout = setTimeout(() => {
					this.removeListener(event, resolve);
					resolve(undefined);
				}, this._dispatch_timeout);

				this.once(event, (ans) => {
					clearTimeout(timeout);
					// push or replace to setlocals []
					if (value !== undefined && ans._success) {
						let idx = this._setlocals.length;
						for (let i = 0; i < this._setlocals.length; i++) {
							if (this._setlocals[i].name === name) {
								idx = i;
								break;
							}
						}
						this._setlocals[idx] = { name: name, value: value };
					}
					resolve(ans._success ? ans._retvalue : undefined );
				});
			});
		}
	}

	/**
	 * Enqueues the Message in the Yate engine
	 * @method
	 * @param {YateMessage} message (required)
	 * @example
	 * const {Yate, YateMessage} = require("next-yate");
	 * let yate = new Yate();
	 * yate.init();
	 * let m = new YateMessage("call.drop", false, { id: "sip/123" });
	 * yate.equeue(m);
	 * @see Yate#dispatch
	 */
	enqueue(message) { this._dispatch(message) }

	/**
	 * Dispatches the Message in the Yate engine
	 * @method
	 * @param {Function} callback - Callback function (optional, if undefined returns promisyfied value)
	 * @param {YateMessage} message (required)
	 * @async
	 * @example
	 * const {Yate, YateMessage} = require("next-yate");
	 * let yate = new Yate();
	 * yate.init();
	 * // callback variant
	 * let m = new YateMessage("call.route", false, { id: "test/1", caller: "123", called: "321" });
	 * yate.dispatch(res => console.log(res.retValue()), m); // Output to console call.route request result
	 * // or async/await variant
	 * let res = await yate.dispatch(m);
	 * console.log(res.retValue());
	 * @see Yate#enqueue
	 */
	dispatch(callback, msg) {
		// callback version
		if (typeof callback === "function" && msg) {
			if ("_id" in msg && "_name" in msg && "_time" in msg) {
				this._dispatch(msg);
				this.once("_answer," + msg._id, callback);
			}
			return;
		}
		// promise version without callback
		if (callback && typeof callback === "object") {
			if ( "_id" in callback && "_name" in callback && "_time" in callback ) {
				msg = callback;
				return new Promise(resolve => {
					this._dispatch(msg);
					let event = "_answer," + msg._id;
					// kill the slow dispatch by timeout
					let timeout = setTimeout(() => {
						this.removeListener(event, resolve);
						msg._handled = false;
						resolve(msg);
					}, this._dispatch_timeout);
					this.once(event, (m) => {
						clearTimeout(timeout);
						resolve(m);
					});
				});
			}
		}
	}

	/**
	 * Output data to Yate log.
	 * @method
	 * @param {string} line
	 */
	output(...args) {
		args.join(" ").split("\n").forEach(l => this._output(l));
	}

	// External module command flow reader
	_read(line) {
		if (this._debug) this.emit("_debug", "<-- " + line);
		let msg = _parseMessage(line);
		switch (msg._type) {
			case "error":
				this.emit("_error", msg._retvalue);
				break;
			case "setlocal":
				this.emit("_setlocal," + msg._name, msg);
				break;
			case "incoming":
				this.emit(msg._name, msg); // installed
				break;
			case "uninstall":
				this.emit("_uninstall," + msg._name, msg._success);
				break;
			case "notification":
				this.emit(msg._name, msg); // watched
				break;
			case "install":
				this.emit("_install," + msg._name, msg._success);
				break;
			case "answer":
				this.emit("_answer," + msg._id, msg); // dispatched
				break;
			case "watch":
				this.emit("_watch," + msg._name, msg._success);
				break;
			case "unwatch":
				this.emit("_unwatch," + msg._name, msg._success);
		}
	}

	/*
	 * External module protocol, direction application -> engine
	 */
	_write(line) {
		if (line.length > this.bufsize) line = line.substr(0, this.bufsize); // trim the line to max buffer size
		if (!this._connected) {
			// scheduled line
			this.once("_connect", () => { this._write(line) });
		} else {
			if (this._debug) this.emit("_debug", "--> " + line);
			this.out.write(line.endsWith("\n") ? line : line + "\n");
		}
	}

	// %%>connect:<role>[:<id>][:<type>]
	_connect(role, id, type) {
		if (role.match(/^(global|channel|play|record|playrec)$/))
			this._write("%%>connect:" + role + ":" + _escape(id) + ":" + _escape(type));
	}

	// %%>output:arbitrary unescaped string
	_output(line) {
		if (line.length > this.bufsize) line = line.substr(0, this.bufsize); // trim the line to max buffer size
		// use its own out.write without debug! loops
		if (!this._connected) {
			// scheduled command
			this.once("_connect", () => { this._output(line) });
		} else {
			this.out.write("%%>output:" + _unescape(line.endsWith("\n") ? line : line + "\n"));
		}
	}

	// %%<message:<id>:<processed>:[<name>]:<retvalue>[:<key>=<value>...]
	_acknowledge(msg) {
		if (msg._type !== "incoming" || msg._acknowledged) return;
		msg._acknowledged = true;
		this._write("%%<message:" + _escape(msg._id) + ":" + _bool2str(msg._handled) + "::" + _escape(msg._retvalue) + _par2str(msg));
	}

	// %%>setlocal:<name>:<value>
	_setlocal(name, value) { this._write("%%>setlocal:" + name + ":" + _escape(value)) }

	// %%>watch:<name>
	_watch(name) { this._write("%%>watch:" + _escape(name)) }

	// %%>unwatch:<name>
	_unwatch(name) { this._write("%%>unwatch:" + _escape(name)) }

	// %%>install:[<priority>]:<name>[:<filter-name>[:<filter-value>]]
	_install(name, priority, filter, fvalue) {
		priority = ("" + priority).match(/^\d+$/) ? priority : 100;
        if (filter && fvalue)
            this._write("%%>install:" + priority + ":" + _escape(name) + ":" + filter + ":" + fvalue);
        else
            this._write("%%>install:" + priority + ":" + _escape(name));
	}

	// %%>uninstall:<name>
	_uninstall(name) { this._write("%%>uninstall:" + _escape(name)) }

	// %%>message:<id>:<time>:<name>:<retvalue>[:<key>=<value>...]
	_dispatch(msg) {
		if (msg._type !== "outgoing") return;
		this._write("%%>message:" + _escape(msg._id) + ":" + msg._time + ":" + _escape(msg._name) + ":" + _par2str(msg));
	}
}

/*
 * Dump stream to string
 * Emits the event "dump" when dump is finished
 */
class DumpStream extends Writable {
	constructor(options) {
		super(options);
	}
	_write(chunk, encoding, callback) {
		let dump = "";
		dump += chunk;
		callback();
		this.emit("dump", dump);
	}
}

/*
 * External module protocol, direction application <- engine
 * https://docs.yate.ro/wiki/External_module_command_flow
 */
function _parseMessage(str) {
	let arg = str.split(":");
	let params = {};
	switch (arg[0]) {
		case "%%>message": // %%>message:<id>:<time>:<name>:<retvalue>[:<key>=<value>...]
			params._id = arg[1];
			params._time = arg[2];
			params._name = arg[3];
			params._retvalue = _unescape(arg[4]);
			params._type = "incoming";
			params._acknowledged = false;
			break;
		case "%%<message": // %%<message:<id>:<processed>:[<name>]:<retvalue>[:<key>=<value>...]
			params._id = arg[1];
			params._handled = _str2bool(arg[2]);
			params._name = arg[3];
			params._retvalue = _unescape(arg[4]);
			params._type = params._id ? "answer" : "notification";
			break;
		case "%%<install": // %%<install:<priority>:<name>:<success>
			params._priority = arg[1];
			params._name = arg[2];
			params._success = _str2bool(arg[3]);
			params._type = "install";
			break;
		case "%%<uninstall": // %%<uninstall:<priority>:<name>:<success>
			params._priority = arg[1];
			params._name = arg[2];
			params._success = arg[3];
			params._type = "uninstall";
			break;
		case "%%<watch": // %%<watch:<name>:<success>
			params._name = arg[1];
			params._success = _str2bool(arg[2]);
			params._type = "watch";
			break;
		case "%%<setlocal": // %%<setlocal:<name>:<value>:<success>
			params._name = arg[1];
			params._retvalue = _unescape(arg[2]);
			params._success = _str2bool(arg[3]);
			params._type = "setlocal";
			break;
		case "Error in":
		default:
			params._type = "error";
			params._retvalue = str;
	}
	// message param parser
	if (
		params._type === "incoming" ||
		params._type === "answer" ||
		params._type === "notification"
	) {
		let par = arg.slice(5);
		for (let i = 0; i < par.length; i++) {
			let pos = par[i].indexOf("=");
			if (pos > 0) {
				let key = par[i].substr(0, pos);
				params[_unescape(key)] = _unescape(par[i].substr(pos + 1));
			}
		}
		// parent.child -> parent { child }
		params = _str2obj(params);
	}
	return new YateMessage(params._name, params);
}

/*
 * Every command is sent on its own newline (\n, ^J, decimal 10) delimited line.
 * Any value that contains special characters (ASCII code lower than 32) MUST have them converted to %<upcode>
 * where <upcode> is the character with a numeric value equal with 64 + original ASCII code.
 * The % character itself MUST be converted to a special %% representation.
 * Characters with codes higher than 32 (except %) SHOULD not be escaped but may be so.
 * A %-escaped code may be received instead of an unescaped character anywhere except in the initial keyword or the delimiting colon (:) characters.
 * Anywhere in the line except the initial keyword a % character not followed by a character with a numeric value higher than 64 (40H, 0x40, "@") or another % is an error.
 */
function _escape(str, extra) {
	if (str === undefined || str === null) return "";
	str = str + ""; // all to string
	let res = "";
	for (let i = 0; i < str.length; i++) {
		let chr = str.charAt(i);
		if (chr.charCodeAt(0) < 32 || chr === ":" || chr === extra) {
			chr = String.fromCharCode(chr.charCodeAt(0) + 64);
			res += "%";
		} else if (chr === "%") {
			res += chr;
		}
		res += chr;
	}
	return res;
}

function _unescape(str) {
	let res = "";
	for (let i = 0; i < str.length; i++) {
		let chr = str.charAt(i);
		if (chr === "%") {
			i++;
			chr = str.charAt(i);
			if (chr !== "%") chr = String.fromCharCode(chr.charCodeAt(0) - 64);
		}
		res += chr;
	}
	return res;
}

// false -> "false"
function _bool2str(bool) {
	return bool ? "true" : "false";
}

// "true" -> true
function _str2bool(str) {
	return str === "true";
}

// stringify message params
function _par2str(msg, empty = false) {
	msg = _obj2str(msg);
	let res = "";
	for (let key in msg) {
		if (
			("" + key).charAt(0) === "_" ||
			typeof msg[key] === "object" ||
			typeof msg[key] === "function"
		)
			continue;
		let val = msg[key].toString();
		if (val) {
			res += ":" + _escape(key) + "=" + _escape(val);
		} else if (empty) {
			res += ":" + _escape(key);
		}
	}
	return res;
}

// stringify object
function _obj2str(obj, rootkey) {
	let res = {};
	let pref = rootkey ? rootkey + "." : "";
	for (let key in obj) {
		if (("" + key).charAt(0) === "_") continue;
		if (typeof obj[key] === "function") continue;
		if (typeof obj[key] === "object") {
			let subobj = _obj2str(obj[key], key);
			for (let subkey in subobj) {
				res[pref + subkey] = subobj[subkey];
			}
		} else {
			let val = obj[key].toString();
			if (rootkey === key) {
				res[key] = val;
			} else {
				res[pref + key] = val;
			}
		}
	}
	return res;
}

// parent.child -> parent: { child }
function _str2obj(obj) {
	let res = {};
	for (let key in obj) {
		let val = obj[key];
		if (val === "false") {
			val = false;
		} else if (val === "true") {
			val = true;
		}
		if (key.indexOf(".")) {
			key.split(".").reduce((object, key, index, arr) => {
				if (index === arr.length - 1) {
					if (typeof object === "object" && key in object) {
						object[key][key] = val;
					} else {
						object[key] = val;
					}
				} else {
					if (typeof object === "object" && key in object) {
						if (typeof object[key] !== "object") {
							object[key] = { [key]: object[key] };
						}
					} else {
						object[key] = {};
					}
				}
				return object[key];
			}, res);
		} else {
			res[key] = val;
		}
	}
	return res;
}

// object copy
function _deepCopy(dst, src, prefix = "_", skip = true) {
	for (let key in src) {
		if (key.startsWith(prefix) && skip) continue;
		if (typeof src[key] === "function") continue;
		if (typeof src[key] !== "object") {
			dst[key] = src[key];
		} else {
			dst[key] = {};
			_deepCopy(dst[key], src[key]);
		}
	}
	return dst;
}

module.exports = {
	Yate,
	YateMessage,
	DumpStream
};
